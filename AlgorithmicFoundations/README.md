# Algorithmic Foundations

## 基本的なデータ構造とアルゴリズム

### ADT（抽象データ型）

ADT（Abstract Data Type）とは、具体的な実装は定義されておらず、単にどのような操作を持つかということのみが定義された抽象的なデータ型。例えば、スタックというADTはpush、popという操作を持つデータ型であるが、具体的な実装は規定されていない。他に、リスト、セット、辞書、キュー、ツリー、グラフなどもADTである。

例えばマップは、キーとそれに対応する値のペアを持ち、挿入（insert）、削除（delete）、検索（find）などの操作を持つADTだが、具体的な実装方法は規定されておらず、GoやPythonでは内部的にはハッシュテーブルを用いて実装されているのに対し、C++では平衡二分探索木（赤黒木）を用いて実装されている。

対してデータ型は、データの内部表現や操作方法がプログラミング言語やユーザーによって明確に定義されたデータ型である。例えば、int、float、charなどの基本データ（primitive）型や、配列、構造体、クラスなどの複合データ型、列挙型（Enum）などがデータ型であると言える。

### 配列

#### 数値配列と非数値配列、文字列

C++やRustでは、行列（matrix）との対比で、（１次元）配列のことをベクトル（vector）とも呼ぶ。データの追加や削除などの操作を持ち、特に末尾にデータを追加する操作をpush-back、末尾からデータを取り出す操作をpop-backと呼ぶ。

基本データ型としての配列型とクラスとしての配列型の２種類がある。基本データ型としての配列型はCの配列のように単なるアドレスでしかなく、対してクラスとしての配列型にはさまざまなメソッドが定義されており、基本データ型としての配列型をより便利に操作できるようにしたラッパーとなっている。

クラスとしての配列型には容量（capacity）というパラメータを指定でき、例えば要素は３つしか入っていないが、容量は８になっている場合などある。容量を超える要素を格納する必要がある場合は、新しくより大きい領域を用意して、すでにある要素をそこにコピーする必要がある。

新しい領域を用意する際に容量を１つしか増やさないとすると、要素の数が$n$個の場合、$n-1$回のコピーが必要になる。つまり$n-1$個の要素を追加する場合は合計で$0 + 1 + 2 + ... + n-1 = \frac{(n-1) \times n}{2}$回のコピーが必要になるため、$O(n^2)$の計算量がかかってしまう。

容量を倍ずつ増やすとすると、$n$個の要素を追加する場合は合計で$0 + 1 + 2 + ... + \log_2 n = O(n)$回のコピーで済む。そのため１回あたりのコピーにかかる平均時間は$O(1)$であり、償却定数時間になる。このように、配列の容量を倍ずつ増やすことをダブリング（doubling）と呼ぶ。

オブジェクトの参照のみをコピーする（参照先オブジェクトは同じものを指す）ことをshallow copyと呼び、オブジェクトの実体もコピーすることをdeep copyと呼ぶ。配列をコピーする際に、配列の要素がポインタやオブジェクトの参照である場合は、その参照先のオブジェクトはコピーされないため、配列のコピーはどちらかというとshallow copyであると言える。

#### １次元配列（ベクトル）と多次元配列（行列）

多次元配列を表現する方法としては、単純に連続したメモリ領域に全ての要素を並べる方法（`data[2][2]`なら`0-0`, `0-1`, `1-0`, `1-1`が連続したメモリ領域に並ぶという感じ）と、配列の中に配列のポインタを並べる方法がある。

プリミティブなやり方は、連続したメモリ領域に全ての要素を並べる方法であり、C/C++でも使われている。この方法のメリットとしては、領域を割り当てるときに一気に領域を確保できることや、ある範囲のデータを一気にコピーするという方法を取りやすいことが挙げられる。一方で、全ての配列を同じ長さにする必要があるというデメリットがあり、一方でポインタを使う方法は各配列の長さを自由に設定できるというメリットがある。

連続したメモリ領域に全ての要素を並べる方法には、行優先（row-major order）と列優先（column-major order）の２種類がある。行優先の場合は行ごとに順にアクセスするとメモリ上ではシーケンシャルなアクセスになる。一方で列優先の場合は列ごとに順にアクセスするとメモリ上ではシーケンシャルなアクセスになる。C/C++、Go、Numpyなどは行優先であり、Fortran、Matlab、Rなどは列優先である。ポインタを使用する方法では、iliffe vectorと呼ばれるデータ構造が用いられており、Java、C#、Scala、Swiftなどがこれを採用している。

行優先やiliffe vectorは、行列の要素を連続したメモリ領域に並べるため、行ごとにアクセスするとキャッシュヒット率が高くなる。列優先は列ごとにアクセスするとキャッシュヒット率が高くなる。

[多次元配列のメモリレイアウト方式について](https://qiita.com/tyoshitake/items/83ce47f169c5b037f06c)

具体的には、例えばCで下記のような２次元配列を宣言した場合、メモリ上では`1, 2, 3, 4, 5, 6, 7, 8, 9`の順に並ぶ。要素へアクセスする際は行と列のインデックスを指定するが、内部的には１次元配列として扱われているため、$\text{行列のベースアドレス} + \text{行インデックス} \times \text{列数} + \text{列インデックス}$のようにしてアドレスが計算される。

```c
int matrix[3][3] = {
  {1, 2, 3},
  {4, 5, 6},
  {7, 8, 9}
};
```

### レコード、構造体、タプル、オブジェクト

レコードは、構造体や複合データとも呼ばれ、データベースでは行と呼ばれる。フィールドの集まりであり、通常は固定の数と並びのフィールドから成り、配列と違って各フィールドのデータ型は異なってよい。各フィールドには名前が付いており、それによってデータにアクセスする。

レコードのフィールドは、言語によってはメンバーあるいはメンバー変数と呼ばれることもある。レコードの専用構文がない言語であっても、クラス構文をサポートする場合は、ほとんどの場面においてクラスで代用可能である。例えばJavaにはレコード型があるが、内部的にはクラスで実現される糖衣構文（syntax sugar、読み書きのしやすさのために導入される書き方）である。

タプルでは、含まれる要素が同じでも要素の順番が異なる場合は別の値として扱われる（`(1, 2)`と`(2, 1)`など）。構造体はより意味のある形の要素の集合というニュアンスを持つが、タプルは単なる要素の寄せ集めというニュアンスを持つ。タプルは配列とは違って順序対という感じで、含まれる要素が変化しないというニュアンスを持たせたいときに使う。ただその場合にも配列を使う人もいるので、そこまで厳密に使い分けられているわけではない。２要素の時は2-tuple、３要素の時は3-tuple、n要素の時はn-tapleと呼ばれる。

オブジェクトはメソッドを持つことができる。言語によってはクラスと呼ばれることもある。また文脈によってはインスタンスやクラスなどをまとめてオブジェクトと呼ぶこともある。
