# 基本２

| アルゴリズム | 最悪計算量 | 平均計算量 | 最良計算量 |最悪空間計算量 | インプレース | 安定性 | Pros | Cons |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| バケットソート | $$O(n^2)$$ | $$O(n + k)$$ | $$O(n)$$ | $$O(nk)$$| No | Yes | 線形時間でソートできる | バケット数が固定または要素数が固定でないと使いにくい |
| カウントソート | $$O(n + k)$$ | $$O(n + k)$$ | $$O(n + k)$$ |  | No | Yes | 線形時間でソートできる | 要素の取りうる値が制限されている必要がある |
| 基数ソート | $$O(nk)$$ | - | $$O(n)$$ | $$O(nk)$$ | No | Yes | 線形時間でソートできる |  |

## 擬似ソート（比較以外の方法によるソート）

前述したように値の比較を基本操作とするソートでは最速でも$$O(n \log n)$$の最悪時間計算量を要するが、比較操作を使わないソートであればより高速（$$O(n)$$）にソートすることができる。そこで必要になるのが、値同士の相対的関係ではなく、値そのものに基づいてアルゴリズムの動作を決めることである。具体的には、値（またはそれに一定の変換を加えたもの）を添字として配列の参照を行う。

比較を用いるソートではソート対象のデータが全順序集合（順序を定めることができる値の集合）であればそれ以上の制約を必要としないが、比較を用いないソートではそれ以上の制約が必要になるため、使い所が限られるのが欠点である。

### バケットソート

バケットソート（bucket sort、バケツソート、ビンソート）では、ソート対象のデータの取りうる値が$$m$$種類であるとき、$$m$$個のバケツを用意し、データ列を走査して、各データを対応するバケツに入れていく。この処理が終わった後、ソートしたい順序に従ってバケツから値を取り出して結合することで、データをソートすることができる。安定ソートを実現するためには、同じバケツに入っているデータは入れたときと同じ順序で取り出す必要がある。

バケツ数を$$k$$個とすると、バケットソートの時間計算量は$$O(n + k)$$であり（$$n$$個の要素を走査して、次に$$k$$個のバケツを結合するため）、要素数が固定またはバケツ数が固定であるなら線形時間（$$O(n)$$）でソートできることになる。ただし、要素の取りうる値が$$k$$種類であるという入力に対する強い制約を持ち、ソート対象の値のモデルに合わせてプログラムを書く必要が生じてしまうため、一般的なソートアルゴリズムとしては使いにくい。

本来はバケツ内でもソートが必要ない場合バケツ内でソートをする必要があるとき、データが非均一で特定のバケツにのみデータが集中し、そのバケツ内でさらに効率の悪いソート（$$O(n^2)$$）を行った場合（例えばクイックソートを使っていて最悪のケースが発生したときなど）、バケットソートの最悪計算量は$$O(n^2)$$になる。

[バケットソート](https://ja.wikipedia.org/wiki/バケットソート)

[Top K Frequent Elements - LeetCode](https://github.com/rihib/leetcode/pull/20)

### カウントソート

カウントソート（counting sort）はバケットソートの一種でもあり、ソート対象のデータに特定の範囲の値しか含まれていないことがわかっている場合、それぞれの値が何回現れるかをカウントすることによってソートするアルゴリズムである。

### 基数ソート

基数ソート（radix sort）は、各桁に対してソートを行い、桁ごとに整列を繰り返すことで全体をソートする。桁ごとのソートにはバケットソートやカウントソートを用いる。

このとき、最小桁から順にソートしていく必要がある。各桁ごとのソートでは他の桁の情報を知ることができないので、最大桁からソートをすると、より小さい桁のソート結果が優先して使われることになってしまう。例えば、$$45, 17, 72$$というデータ列があるとき、最大桁からソートする場合、$$45, 17, 72$$→$$17, 45, 72$$→$$72, 45, 17$$となってしまう。最小桁からソートする場合は、$$45, 17, 72$$→$$72, 45, 17$$→$$17, 45, 72$$となり、正しいソート結果が得られる。

またソートに用いるバケットソートやカウントソートは安定ソートである必要がある。不安定ソートだと一度ソートされた順序が後のステップで維持されない。例えば$$45, 17, 42$$というデータ列があるとき、不安定ソートを使った場合、$$45, 17, 42$$→$$42, 45, 17$$→$$17, 45, 42$$のようになる可能性があり、より小さい桁でソートした順序が維持されることを保証できない。

もちろん桁数の異なる数字同士であっても基数ソートを適用することができる。例えば$$170, 45, 75$$というデータ列があるとき、$$170, 45, 75$$→$$170, 45, 75$$→$$45, 170, 75$$→$$45, 75, 170$$となる。他にも文字列を辞書式順序にソートする場合にも基数ソートを使うことができる。例えば$$"dog", "cat", "ape"$$というデータ列があるとき、$$"dog", "cat", "ape"$$→$$"ape", "dog", "cat"$$→$$"cat", "dog", "ape"$$→$$"ape", "cat", "dog"$$となる。文字列をソートする場合は、文字数が異なる場合には短い方の文字列の後ろに空白文字を追加して文字数を揃えるなどの追加の処理を行う必要がある（しかし、数列をソートする場合も、結局は各桁ごとに処理するために一旦は文字列に変換して処理することに注意）。

$$k$$を桁数（文字数）とすると、各桁ごとに行うバケットソートやカウントソートの時間計算量はバケツ数が固定であることから$$O(n)$$であり、それを$$k$$回繰り返すため、基数ソートの時間計算量は$$O(nk)$$になるが、$$k$$は固定値であるため、実際は$$O(n)$$であると言える。そのため、実用的なアルゴリズムとしては最高速である。ただし、例えばクイックソートと比べてどちらが速いかは慎重な検討を要する。$$k$$の大きさや個々の操作に要する時間によっては、クイックソートの方が速いこともありうる。

[基数ソート](https://ja.wikipedia.org/wiki/基数ソート)<br
[GPU最速ソート! Radix Sort その①](https://qiita.com/tommyecguitar/items/3c1897bceda4a06beef2)
