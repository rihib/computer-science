# 基本２

| アルゴリズム | 最悪計算量 | 平均計算量 | 最良計算量 |最悪空間計算量 | インプレース | 安定性 | Pros | Cons |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| バケットソート | $$O(n^2)$$ | $$O(n + k)$$ | $$O(n)$$ | $$O(nk)$$| No | Yes | 線形時間でソートできる | バケット数が固定または要素数が固定でないと使いにくい |
| カウントソート | $$O(n + k)$$ | $$O(n + k)$$ | $$O(n + k)$$ |  | No | Yes | 線形時間でソートできる | 要素の取りうる値が制限されている必要がある |
| 基数ソート | $$O(nk)$$ | - | $$O(n)$$ | $$O(nk)$$ | No | Yes | 線形時間でソートできる |  |

## 擬似ソート（比較以外の方法によるソート）

前述したように値の比較を基本操作とするソートでは最速でも$$O(n \log n)$$の最悪時間計算量を要するが、比較操作を使わないソートであればより高速（$$O(n)$$）にソートすることができる。そこで必要になるのが、値同士の相対的関係ではなく、値そのものに基づいてアルゴリズムの動作を決めることである。具体的には、値（またはそれに一定の変換を加えたもの）を添字として配列の参照を行う。

比較を用いるソートではソート対象のデータが全順序集合（順序を定めることができる値の集合）であればそれ以上の制約を必要としないが、比較を用いないソートではそれ以上の制約が必要になるため、使い所が限られるのが欠点である。

### バケットソート

バケットソート（bucket sort、バケツソート、ビンソート）では、ソート対象のデータの取りうる値が$$m$$種類であるとき、$$m$$個のバケツを用意し、データ列を走査して、各データを対応するバケツに入れていく。この処理が終わった後、ソートしたい順序に従ってバケツから値を取り出して結合することで、データをソートすることができる。安定ソートを実現するためには、同じバケツに入っているデータは入れたときと同じ順序で取り出す必要がある。

バケツ数を$$k$$個とすると、バケットソートの時間計算量は$$O(n + k)$$であり（$$n$$個の要素を走査して、次に$$k$$個のバケツを結合するため）、要素数が固定またはバケツ数が固定であるなら線形時間（$$O(n)$$）でソートできることになる。ただし、要素の取りうる値が$$k$$種類であるという入力に対する強い制約を持ち、ソート対象の値のモデルに合わせてプログラムを書く必要が生じてしまうため、一般的なソートアルゴリズムとしては使いにくい。

本来はバケツ内でもソートが必要ない場合バケツ内でソートをする必要があるとき、データが非均一で特定のバケツにのみデータが集中し、そのバケツ内でさらに効率の悪いソート（$$O(n^2)$$）を行った場合（例えばクイックソートを使っていて最悪のケースが発生したときなど）、バケットソートの最悪計算量は$$O(n^2)$$になる。

[バケットソート](https://ja.wikipedia.org/wiki/バケットソート)

[Top K Frequent Elements - LeetCode](https://github.com/rihib/leetcode/pull/20)

### カウントソート

カウントソート（counting sort）はバケットソートの一種でもあり、ソート対象のデータに特定の範囲の値しか含まれていないことがわかっている場合、それぞれの値が何回現れるかをカウントすることによってソートするアルゴリズムである。

### 基数ソート

基数ソート（radix sort）は、各桁に対してソートを行い、桁ごとに整列を繰り返すことで全体をソートする。桁ごとのソートにはバケットソートやカウントソートを用いる。

このとき、最小桁から順にソートしていく必要がある。各桁ごとのソートでは他の桁の情報を知ることができないので、最大桁からソートをすると、より小さい桁のソート結果が優先して使われることになってしまう。例えば、$$45, 17, 72$$というデータ列があるとき、最大桁からソートする場合、$$45, 17, 72$$→$$17, 45, 72$$→$$72, 45, 17$$となってしまう。最小桁からソートする場合は、$$45, 17, 72$$→$$72, 45, 17$$→$$17, 45, 72$$となり、正しいソート結果が得られる。

またソートに用いるバケットソートやカウントソートは安定ソートである必要がある。不安定ソートだと一度ソートされた順序が後のステップで維持されない。例えば$$45, 17, 42$$というデータ列があるとき、不安定ソートを使った場合、$$45, 17, 42$$→$$42, 45, 17$$→$$17, 45, 42$$のようになる可能性があり、より小さい桁でソートした順序が維持されることを保証できない。

もちろん桁数の異なる数字同士であっても基数ソートを適用することができる。例えば$$170, 45, 75$$というデータ列があるとき、$$170, 45, 75$$→$$170, 45, 75$$→$$45, 170, 75$$→$$45, 75, 170$$となる。他にも文字列を辞書式順序にソートする場合にも基数ソートを使うことができる。例えば$$"dog", "cat", "ape"$$というデータ列があるとき、$$"dog", "cat", "ape"$$→$$"ape", "dog", "cat"$$→$$"cat", "dog", "ape"$$→$$"ape", "cat", "dog"$$となる。文字列をソートする場合は、文字数が異なる場合には短い方の文字列の後ろに空白文字を追加して文字数を揃えるなどの追加の処理を行う必要がある（しかし、数列をソートする場合も、結局は各桁ごとに処理するために一旦は文字列に変換して処理することに注意）。

$$k$$を桁数（文字数）とすると、各桁ごとに行うバケットソートやカウントソートの時間計算量はバケツ数が固定であることから$$O(n)$$であり、それを$$k$$回繰り返すため、基数ソートの時間計算量は$$O(nk)$$になるが、$$k$$は固定値であるため、実際は$$O(n)$$であると言える。そのため、実用的なアルゴリズムとしては最高速である。ただし、例えばクイックソートと比べてどちらが速いかは慎重な検討を要する。$$k$$の大きさや個々の操作に要する時間によっては、クイックソートの方が速いこともありうる。

[基数ソート](https://ja.wikipedia.org/wiki/基数ソート)<br
[GPU最速ソート! Radix Sort その①](https://qiita.com/tommyecguitar/items/3c1897bceda4a06beef2)

## マッチング

テキストエディタにおける探索コマンド（Cmd + Fなどで文字列検索する場合など）やテキストデータベースにおける検索などに使われる。テキストと呼ばれる文字列の中にパターンと呼ばれる文字列に一致する部分があるかを調べる。テキストはパターンよりも遥かに大きいことが多い。テキストは100万文字以上になることも珍しくなく、対してパターンは10文字程度であることも多い。

計算量を気にしなければ、最もシンプルな方法では、テキストにパターンを重ねて一致するかどうかを調べ、一致しなければ重ねる位置を一つずつずらしていけばいい。この場合、テキスト（$$n$$）に比べてパターン（$$m$$）が十分に小さいとすれば、最悪時間計算量は$$O(nm)$$になる。ただし、実際はパターンの１文字目か２文字目で不一致が判明する場合がほとんどであるため、実用的に見てそれほど問題にならないことが多い。ただ、最悪計算量が$$m$$に比例する点に改良の余地が残っている。

最悪計算量が$$O(nm)$$になるのは、ある位置にパターンを置いて比較した際に得られる情報を十分活用していないためである。例えば、`aaaaa`というテキストと`aaab`というパターンがあるとき、最初の`a`を比較した時点で2文字目と３文字目も`a`であることがわかっているのに、この情報を活用せずに、次のステップでまたパターンの１文字目とテキストの２文字目を比較することになる。マッチングの計算速度をあげるためには、一致するまたは一致しないことがわかっている無駄な比較をできるだけ避けることが重要である。

### 効率的な文字列マッチング（KMP、BP）

#### KMP法

KMP（Knuth-Morris-Pratt）法の比較の回数は最大$$2n$$回であることから、計算量は$$m$$によらずに$$O(n)$$になり、シンプルなマッチング方法の$$O(nm)$$の最悪計算量を回避することができる。実際の文字列処理では両者の計算時間にオーダーで見られるほどの差が出ることは少ないが、やはりKMP法の方が若干速いと言われている。ただ、KMP法は後述するBM法に比べると実用上の性能で劣る。

シンプルなマッチング方法では、途中まで一致して不一致となった場合に、テキスト状を少し引き返してから再度比較を始める必要があるが、KMP法の長所はテキストの上を逆戻りする必要がないため、ファイルからテキストを入力しながら探索を行う場合などにこの性質によって処理が簡単になることがある。

#### BM法

BM（Boyer-Moore）法は、KMP法よりもさらに高速なマッチングアルゴリズムであり、パターンがある程度以上（普通５以上くらい）の長さを持つ場合には、最も速い文字列マッチングアルゴリズムだと言われている。KMP法と同様に最悪計算量は$$O(n)$$である。

シンプルなマッチング方法やKMP法ではテキストの中の文字をそれぞれ１回は調べなければならず、最低でも$$n$$回の比較を行う必要があるのに対し、BM法は$$n/m$$個の文字とだけ比較すればよいことがあり、これによって特にパターンの長さが長い時に計算時間の大幅な短縮が期待できる。この特徴から、（$$O(n^2)$$を$$O(n \log n)$$にするような劇的な高速化とは違って計算時間を数分の１にするだけだが）現実世界ではテキスト探索の使用頻度が高いということもあり、BM法は実用上極めて重要なアルゴリズムとみなされている。

BM法では、シンプルなマッチング方法と同様にテキストを左から順に調べていくが、一旦テキスト上の位置が決まったら、パターンについては逆に右から左に向かって調べる。もちろんマッチングを進めるにあたってはKMP法と同様にそれ以前に行った比較の結果として得られた情報をできるだけ活用して比較の回数を減らすように努める。

BM法では、比較回数を減らすために、不一致が見つかった時に一致しないことがわかっている場所を飛ばして、できるだけ大きくパターンをずらすことを目標とする。まず、不一致となった点のテキストの文字によってパターンをずらす量を決める。これは最初の文字で不一致となった時に最も有効になる。次に、何文字かが一致した後で不一致になった時に一致した部分の情報を利用してずらす量を決める。これは逆に一致した文字数が多いほど効果が大きい。普通はこの２つを組み合わせて使う。
